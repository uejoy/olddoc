[{"id":0,"href":"/docs/interview/operation/op1/","title":"操作题","section":"操作题","content":"\r1、联网操作（蓝图或C++）\r#\r收录时间\n2022年11月12日\n基于虚幻引擎网络框架完成\n2人练机抢夺物品游戏，要求如下：\r#\r场景：一个带有门空房间，房间外有2个桌子 两名玩家联机，有开门动作，跑到一个屋子里面抢夺物品。 屋子里地面上有5个小物品 （可以超过五个，随机） 玩家随机拾取地面上的物品，放到屋外的桌子上 判断2人，谁搬运的物品更多，弹窗提示哪个玩家胜利 完成时间：1-2天内，提交作品视频\n扩展此问题（非面试要求）\r#\r游戏启动等待其他玩家加入，等待时长30秒 如超过30秒未有玩家加入，游戏结束。 玩家加入后必须在30秒内随机选择阵营颜色（游戏最多进入4人，颜色为红，黄，蓝，绿） 玩家可以输入昵称 如出现玩家未选择原色，未选择昵称，则系统随机分配颜色，并分配昵称。原则是，颜色不能重复，昵称不能重复。 根据玩家数量，生成对应颜色的球（位置随机在场景中），每个玩家生成5个球. 生成彩色球，彩色球5个，每个计分2份 对应颜色玩家可以拾取对应颜色的球，并且可以拾取彩色球。例如红色玩家可以拾取红色球或是彩色球，不能拾取其他颜色球。 将球放置到对应颜色的桌子。基础色球每个记1份，彩色球每个记2分。 每人每次只能拾取一个球。 彩色球可以放置到自己颜色桌子（自己加分），或是放置到其他颜色桌子（其他人加分） 游戏中可以随时查看游戏玩家积分情况 游戏胜利条件\r#\r积分模式：场上任意一种颜色球被拾取完毕，并且彩色球被抢夺完毕 计时模式：倒计时60秒，取分数最高的玩家胜利 注意胜利需要弹出胜利窗口，失败玩家提示再接再厉，并告知胜利者是谁\n2、本地图片读取（蓝图或C++）\r#\r收录时间\n2022年11月12日\r读取本地图片（任意二十张图片）； umg中两种展示方式可任意切换； 展示方式一：九宫图，一页九张，切换至最后一页不足九张顺位开头n张补齐。点击任意一张皆可全屏显示。 展示方式二：轮播模式，一排三张，中间为大图预览，两边为小图预览，同时作为上下张翻页按钮，点击左侧小图三张图均切换为当前图片的上一张，点击右侧反之。点击中间大图全屏显示。 3、UMG测试（蓝图或C++）\r#\r收录时间\n2022年11月12日\n引擎版本4.27+\numg树形结构：层级要求四级以上；一级管理者三到四个，二级管理者1~9人，三级管理者（0~9），四级以上（0~9）（需有一组体现出0） 推荐使用UMG TreeView。 员工模型（可用基础模型示意），同一类别（部门，下文中类别同义）用同种模型示意，职级大小用模型缩放示意。 员工模型上方显示两个字段，分别为职位、姓名。 不同类别站不同区域，同一级别站同一行。 点击umg列表中员工，与之对应的员工模型及职位姓名变色，其他未被此次点击的员工还原。 建议UMG列表与员工模型为自动生成（通过配置表）。使用TreeView\n参考示例\r#\rThere should have been a video here but your browser does not seem\rto support it.\r4、画线操作（蓝图或C++）\r#\r收录时间\n2022年03月11日\n引擎版本4.27+\n描述：在UE4场景中，鼠标每次点击时，拾取点中物体的坐标位置（鼠标点击的那个位置），将鼠标点击位置进行空间画线。当结束功能时，给出空间线的总长度。\n5、C++链表测试（C++）\r#\r收录时间\n2022年03月11日\r描述：用UE C++写一个简单的程序。使用链表方式，做一个简单的数据求和的功能。\n6、综合操作（蓝图和C++）\r#\r收录时间\n2022年03月11日\n必须使用蓝图和C++混编\n描述：用UE C++写一个自己的actor，这个actor包含一个碰撞体，和一个3DWidget,要求3DWidget上边带有数字。在编辑器中，用BP脚本实例化这个actor（可以是任意形状、正方体、球体），当鼠标点击这个actor后，弹出3DWidget。用BP另外建一个UI，这个UI上可以输入数字，当在这个UI输入数字后，actor弹出的3DWdiget上的数字要跟着改变。\n7、蟋蟀互斗（蓝图或C++）\r#\r收录时间\n2021年08月25日\n优先选用蓝图完成\n注意审题，操作方式实现方式随意，需要贴合设计题目\n斗蟋蟀交互内容：\n参考图示，用两个简单物体代表两只蟋蟀，蟋蟀分为红方和蓝方，各有2点血（要能看出头部方向，可以用BOX代替）\n两个物体的运动限制在一个圆圈范围以内，两个物体随机朝着对方进行跳跃攻击，被攻击的一方会向后撤步，攻击方会扑空，然后两只蟋蟀，退回到中间位置，再进行随机判定。\n整个循环中，会随机出现一个倒计时的时间（两组倒计时时间不少于5秒），在倒计时的期间，如果用鼠标对其中红方的头部进行点击，红色蟋蟀便会跳跃起来咬向蓝方，蓝方会扣一点血（扣完后，两只蟋蟀归位）。如果第二次撩拨蟋蟀成功，红色会咬向蓝色，蓝色2点血减完便会显示死亡，画面显示我方成功。如果两次倒计时后，都没有来得及点蟋蟀头部，蓝色便会咬向红色，红色死亡，画面显示敌方成功。\n8、蓝图动画题（蓝图）\r#\r收录时间\n2022年03月27日\n优先选用蓝图完成\n创建接口，输入输出参数int数组 Actor实现接口，进行排序 Level关卡生成int数组，进行初始化10个元素[1,100]，接口实现排序 数组最大值 - 最小值 = val，0 \u0026lt; val \u0026lt; 50 人在原地走，50 \u0026lt; val \u0026lt; 80 人上身走，下身跑，val \u0026gt; 80人自动走到一个固定点 根据val值生成多个A，每行15个，以UMG输出到屏幕 9、飞行模拟（C++）\r#\r收录时间\n2022年01月06日\n此题难度较大，绕不开C++\n一周时间发相应录屏（能从视频中看到下面的考查点），此题为开发性题目，作为评估岗位能力主要依据\n第一题：引擎（UE4或者U3D，根据应聘岗位自选）+网络+小算法\n制作一服务器端，场景不做要求（可以网上下载一个可以反映飞机的运动感觉的场景），界面上有两个按钮，一个自动模式，一个手动模式，程序启动后默认为自动。场景默认显示一飞机沿设定好的路线在飞(考查路径跟踪算法）。点击手动模式按钮，此时可以用键盘鼠标等手动控制飞机飞行。能控制飞机俯仰（限定俯仰角-30-30之间）、偏航、加速、减速，横滚(限定横滚角-30-30之间)。再点击自动模式，飞机能平滑飞回原先的航线（考查切回航线算法）沿设定路线飞行。\n客户端连接后，本服务器向客户端每隔一帧发送当前飞机姿态和位置。客户端根据服务器发来的位置和姿态同步显示客户端程序内置的飞机。\n说明：路线为首尾连接可循环路线。路线的任意一个关键点与下一个点之间大于1公里，路线总距离大于50公里。\n网络请使用原始Sokect模式编写，UDP或者TCP可以自选。\n10、沙盘类项目测试（蓝图）\r#\r收录时间\n2021年05月29日\n此题较为简单，使用蓝图完成即可，注意操作反馈\n参照视频完成项目制作\nThere should have been a video here but your browser does not seem\rto support it.\r11、商城功能测试（C++或蓝图）\r#\r收录时间\n2021年11月25日\n注意考虑数据驱动逻辑\n要求：道具信息需要读取本地JSON文件，商店信息需要读取本地JSON。\n素材可以根据实际情况寻找\n基础需求\r#\r搭建测试场景，并摆放多个NPC 每个NPC挂载一种商店（布料店，武器店，防具店，材料店） 走进NPC点击开启弹窗，选择进入商店或是对话（对话可以随意设计，添加随机内容） 打开商店页面，要求显示商店内容与玩家背包 玩家背包限制格子数量，例如最大格子20各 拖拽道具到背包为购买，拖拽道具到商店为出售。 出售道具价格为购买价格的70% 鼠标悬停显示道具信息（图标，名称，等级，价格，品质，属性，用途，描述等，不限） 拓展部分\r#\r可设计道具堆叠特性，购买时填入购买数量 出售时堆叠道具可选出售数量 堆叠道具可自动堆叠到背包中已有道具上 增加道具排序功能，例如遵循价格，品质等 增加筛选功能 增加搜索功能 增加整理功能（整理规则随意设定） 寄售行\r#\r可设计寄售行系统，所有背包道具可以挂载到寄售行完成道具寄售 玩家可以选择寄售行撤销出售道具 设计联网，其他玩家可以通过网络购买寄售行道具 寄售行道具出售后，卖方接收到信息，提示道具出售成功，获取收益 注意：无需考虑存储问题\n12、操作题测试\r#\r收录时间\n2019年11月6日\n蓝图或是C++完成均可\n做个umg，随机输入十个数，后台进行排序，展示最大值。如果最大值小于50，人从a点走到b点。如果值在60-80之间，做一个人物动画混合，上身走下身跑。如果在80-100之间，给场景物体做一个描边。\n13、两道实训测试\r#\r收录时间\n2019年10月24日\n真实面试企业需求题，二选一\n蓝图或是C++完成均可\n实训题一:\r#\r声纳光波效果-\u0026gt;设置一个actor为需要找寻的物体，发射声纳光波，碰到需要找寻的物体.物体返回不同颜色的光波\n实训题二\r#\r制作一个简单的弹药系统，弹药量(30/60)\n描述:做一个弹药箱，移动到附近范围，按下E键可补充弹药(后备弹药充足，面版提示“后备弹药已满”，后备弹药不满时，按下E可补充后备弹药和弹夹弹药，面版提示“正在补给”，三秒后补充完毕。补充时中断则不予补给弹药。)UI面版展示弹药实时数据。 R键换弹(后备弹药填装到弹 夹，并可以发射)\n弹夹为0不能发射。\n14、翻页操作题\r#\r收录时间\n2019年5月17日\n蓝图或是C++完成均可，注意翻页过程中如果增加动画体验会更好\n基本功能：\n使用UMG完成一个翻页功能，可以向左（上一张）向右（下一张）翻页，以及退出功能。翻页效果不限，用图需清晰比例正确。 可以同时显示三张图，如下图。 双击中间的图可以全屏显示，全屏显示后依然能够翻页，如下图。 加分项1：项目发布后，客户依然可以在指定路径下更换图片。 加分项2：鼠标滑动屏幕完成翻页。 加分项3：同时能够兼容播放视频。 15、火烧绳子问题\r#\r收录时间\n2018年8月1日\n蓝图或是C++完成均可\n注意：由于素材缺失，故可以读一下操作即可\n请使用桌面上名为[ExamProject] 的项目\n玩家是一根火柴柜子把手上有绳子系着，需要用火柴将绳子烧断要求: 火柴必须具有可扩展性点燃与被点燃请使用接口来实现(比如突然想让你点燃其他物体能快速的让其他物体实现被点燃的效果)“禁止使用 GetAlIActorsr 禁止绳子直接访问柜子的方法，请使用接口或 Dispatchert\n天花板会滴水，滴到绳子上，玩家如果直接烧绳子，绳子上燃烧的火焰就会被 水打灭，绳子不会被烧开“ 要求\n请留意当将滴水与绳子在游戏地图上分开时请解决无限生成等会导致性能较低的问题，使其即使滴落到地面上也没问题”\n玩家需要按下E键可在自己所在的位置创造出随机物体(书，瓶子等)挡在绳子上面才可以成功将绳子烧断 要求\n物体必须开启物理模拟，水滴不能将遮挡的物体打飞e 0在满足以上条件的情况下可自由发挥，保持逻辑清晰即可+\n"},{"id":1,"href":"/docs/chatserver/scsproto/","title":"SCS服务器","section":"聊天服务器","content":"\rSimple Chat Server\r#\r文档说明\n目前适用版本1.0\n服务器基于C#完成设计\n协议文档只适用于SCS服务器\n说明\r#\r一款简单的基于UDP/IP协议完成的聊天通信服务器。不限定客户端类型，通信消息格式采用UTF-8纯文本，未做协议加密压缩等。\n协议消息均采用JSON格式，方便学习练习。\n服务器未作复杂校验，未做过多容错操作。可能存在BUG，测试中需要注意线程死锁，或是线程崩溃问题。关于线程调度已经进行优化，尽量保证不不出现线程锁问题。未适用线程池，故不适合超过100用户量链接。\n服务器通信协议采用HTTP和SOCKET，其中HTTP只是用POST\n关于公网部署，可根据自身网络环境进行调整，不做说明。\n协议名词\r#\r标记 说明 上行 表明从客户端向服务器端发送消息 下行 表明从服务器端向客户端发送消息 ID 每个协议都应该带有的字段，并且字段值在协议中唯一存在 通信类型 一般指Socket或是HTTP通信 协议结构\r#\r本服务器协议结构采用JSON方式通信，如更换协议结构可只替换协议层不用更换协议内容。\nJSON结构为外层对象型，内层字段\n{\r\u0026quot;id\u0026quot; : \u0026quot;\u0026quot;,\r...\r}\r协议表述（客户端上行）\r#\r消息通过HTTP的POST传递\n注册账号\r#\r字段 类型 说明 id int 1000 account string password string 服务器注册账号\n登录账号\r#\r字段 类型 说明 id int 1001 account string password string 服务器登录账号\n以下协议通过SOCKET通信\n校验换取TOKEN\r#\r当链接Chat服务器后，需要在1分钟内校验TOKEN并换取新的TOKEN，否则将会被踢下线。暂未增加IP访问冷静期限制。\n上服务器后第一件事必须校验TOKEN否则无法做其他动作\n字段 类型 说明 id int 1002 token string 服务器校验Token结果\n更换昵称\r#\r字段 类型 说明 id int 1003 userName string 服务器更换昵称结果\n发送群消息\r#\r字段 类型 说明 id int 1004 msg string 发送私密消息\r#\r字段 类型 说明 id int 1005 tName string 接收者名称 msg string 协议表述（服务端下行）\r#\r错误消息\r#\r所有错误消息均走此协议，协议会告知上行消息错误ID，可以根据错误ID处理逻辑\n字段 类型 说明 id int 40404 cId int 客户端上行ID msg string 错误消息 errorId int 预留字段，用于后期拓展更多错误！ 消息成立\r#\r所有无携带数据消息并成立，会通过此协议完成通知！\n字段 类型 说明 id int 66666 cId int 客户端上行ID 登录账号\r#\r字段 类型 说明 id int 2000 code int 0 token string 每个用户登录聊天服务器的唯一标识（60秒超时） ip string 聊天服务器地址 port number 聊天服务器端口 结果码描述：\n0 成功 1 账号不存在 2 密码错误 3 未知错误 校验换取TOKEN\r#\r字段 类型 说明 id int 2001 token string userName string 服务器给你的临时昵称 收到消息\r#\r字段 类型 说明 id int 2002 type int 0世界，1私聊，2系统 msg string origin string 消息发送者 用户上下线\r#\r字段 类型 说明 id int 2003 type int 0上线 1下线 name string 用户昵称 用户修改昵称\r#\r字段 类型 说明 id int 2004 old string 旧昵称 new string 新昵称 注册账号\r#\r字段 类型 说明 id int 2005 code int 结果码 结果码描述：\n0 成功 1 账号已存在 2 账号格式错误 3 密码格式错误 4 未知错误 上行测试消息\r#\r校验token\r#\r{\u0026quot;id\u0026quot;:1002, \u0026quot;token\u0026quot;:\u0026quot;hxsd\u0026quot;}\r更换昵称\r#\r{\u0026quot;id\u0026quot;:1003, \u0026quot;userName\u0026quot;:\u0026quot;测试员\u0026quot;}\r发送群聊\r#\r{\u0026quot;id\u0026quot;:1004, \u0026quot;msg\u0026quot;:\u0026quot;这是群消息测试\u0026quot;}\r发送私聊\r#\r{\u0026quot;id\u0026quot;:1005, \u0026quot;tName\u0026quot;:\u0026quot;xxx\u0026quot; ,\u0026quot;msg\u0026quot;:\u0026quot;这是测试私聊消息！\u0026quot;}\r测试账号\r#\r测试账号：test 密码：test\r"},{"id":2,"href":"/docs/interview/qa/basequestion/","title":"常见问题","section":"问答题","content":"\r常见问题整理\r#\r本序列问题会不停更新\n所有内容均来自真实面试企业提问，收集内容为开放式问答，需要自行整理答案，切记发散知识，不要只关注问题的表面！\rC++语言\r#\rcpp中动态库和静态库区别\ncpp中指针是不是数据结构\ncpp中定义常量使用宏还是const\n简单阐述下你认为运算符重载的意义\n阐述下设计模式中单例模式的意义\n说一说你使用过得版本控制工具，描述下使用中的问题\ncpp中，友元的优点和缺点\n面相对象的特性\n面相对象的设计原则 六个\n阐述下智能指针的实现手段和意义\n说出你认识的设计模式，阐述他们的特点，不少于五个\n针对接口编程的意义\n数组指针和指针数组区别\n指针数组加减一是否有意义？为什么？\ncpp中头文件的意义\n内联函数的意义\n虚函数实现，虚函数表\n虚继承相关知识了解（菱形继承）\n指针和引用的区别\n★ 相同点:\n都是地址的概念;指针指向一块内存，它的内容是所指内存的地址;引用是某块内存的别名。 ★ 区别:\n指针是一个实体，而引用仅是个别名; 引用使用时无需解引用(*)，指针需要解引用; 引用只能在定义时被初始化一次，之后不可变;指针可变; 引用没有 const，指针有 const; 引用不能为空，指针可以为空; “sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身(所指向的变量或对象的地址)的大小; 指针和引用的自增(++)运算意义不一样; 从内存分配上看:程序为指针变量分配内存区域，而引用不需要分配内存区域。 进程和线程的区别\n共用体是什么？\nC++中的多态是什么？\nC++11特性列举一些\nnullptr和NULL的区别\n宏编写逻辑体和使用函数的区别\n手写设计模式\nmain函数执行前后做了什么？\nmain函数为什么要返回数据整型\nC++在普通平台的差异一般有哪些？简单说一下\n结构体中添加函数，在内存中如何分配？\n虚幻引擎\r#\rue中，正向是坐标系中的哪个轴\n在场景中创建actor的方法\n向蓝图暴露变量的宏是哪个？\nue中如何创建uobject对象\n阐述下gamemode在ue框架中的意义\n如何使用charactermovement飞行？\nfstring,fname,ftext的使用场景举例下\nCDO class default object\n算法相关\r#\r阐述下二分查找法的时间复杂度是什么？ 数据结构中栈和队列区别 动态规划 数组排序 正态分布 排序算法 二叉树 红黑树 平衡二叉树 散列（算法特性和应用（容器map，stl模板库vector）） 手写链表并完成反转 数据结构\r#\r斐波那契数列 链表是什么？手写单向链表和双向链表 如何确定环形链表的头 数组和vector的区别 什么是堆 什么是栈 用C++完成设计栈 3D数学\r#\r点乘叉乘意义 欧拉角的优缺点 "},{"id":3,"href":"/docs/interview/qa/qha/","title":"整理带答案","section":"问答题","content":"\r常见问题进行梳理带答案\r#\r以下为某同学将常见问题整理后，预留答案并分享\r1、点乘叉乘意义\r#\r点乘： 按照说法是向量a在b向量上的投影。 一般根据点乘来判断是否是垂直（0），两向量的相似度(夹角越小，越相似）等；但我在使用中更多是进行反三角计算角度。\n叉乘： 按照说法是a，b向量叉乘得到的新向量C垂直于a，b向量所在的平面，如果为0，说明两向量是平行的。 一般我用于计算法线向量。\n2、ue中，正向是坐标系中的哪个轴\r#\rUE4的X轴是前方。 UE4中，Rotation的X是翻滚角Roll,围绕X轴旋转。Y是俯仰角pitch，围绕Y轴旋转。Z当然是偏航角yaw了，围绕Z轴。\n3、在场景中创建actor的方法\r#\r使用SpawnActor方法根据类生成Actor\n4、向蓝图暴露变量的宏是哪个？\r#\rEditAnywhere： 表示此属性可以通过属性窗口，原型和实例进行编辑（原型指的是类模板，实例指的是具体的对象实例）\nBlueprintReadWrite： 设置属性为蓝图读写。会在蓝图脚本中为被修饰的变量提供 Get 和 Set 方法\n5、ue中如何创建uobject对象\r#\r调用 NewObject() 函数来创建 UObject 对象\n6、阐述下gamemode在ue框架中的意义\r#\r一个游戏世界的mode，规则，逻辑。 游戏的规则,包括玩家如何加入游戏,能否暂停游戏,地图切换,胜利的条件等.一般一个Level下只有一个GameMode.在多玩家游戏中,GameMode仅存于服务器端.\n主要功能有： Class登记、 游戏内实体的Spawn、 游戏的进度、 Level的切换、 多人游戏的步调同步\n7、如何使用charactermovement飞行？\r#\rCharacter 的 setMovementMode 设置flying\n8、fstring,fname,ftext的使用场景举例下\r#\rFName： FName这个字符串类是用来给某个东西命名（Name）的，也就是说作为一个东西的ID。这里说的东西可以是编辑器Content浏览窗口里看到的各种资源，可以是动态材质实例里的某个可设置的参数，还可以是模型骨架中某个具体的骨骼，以及比如角色mesh里用来attach武器的socket。 当FName对象创建时，会根据字符串内容计算出一个hash值，并根据这个hash值把原始的字符串存到一张hash表里。FName对象里会记录自己所在的hash表的索引值，这样在实现比较逻辑时，它就不需要比较字符串内容，而是直接比较索引值是否相等。另外FName对象为不可变对象（immutable），即它被创建后就不能被修改了。它的这种只读属性使得它是天然的线程安全的。 需要注意的是FName是不区分大小写的。\nFText： 在你的游戏中玩家所能见到的文本都应该用FText来做，比如在UI上的文本显示。总而言之，假如你希望利用这个实验性的功能来方便的实现多语言支持，那么就用FText。\nFString： 它创建后是可修改的（mutable）。它提供大量操作字符串的方法，比如将字符串倒序，获取某个子串等。在你的程序内部，做比如拼装一个URL等逻辑时就会用到它。需要注意的是，因为它的可修改特性，它对性能不是那么的友好，另外在线程间共享时需要很注意。\n9、cpp中动态库和静态库区别\r#\r二者的不同点在于代码被载入的时刻不同。\n静态库在程序编译时会被连接到目标代码中，程序运行时将不再需要该静态库，因此体积较大。 动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入，因此在程序运行时还需要动态库存在，因此代码体积较小。 动态库的好处是，不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例。\n10、cpp中指针是不是数据结构\r#\r不是\n11、cpp中定义常量使用宏还是const\r#\r都可以\n类型和安全检查不同 宏定义是字符替换，没有数据类型的区别，同时这种替换没有类型安全检查，可能产生边际效应等错误； const常量是常量的声明，有类型区别，需要在编译阶段进行类型检查 编译器处理不同: 宏定义是一个\u0026quot;编译时\u0026quot;概念，在预处理阶段展开，不能对宏定义进行调试，生命周期结束与编译时期； const常量是一个\u0026quot;运行时\u0026quot;概念，在程序运行使用，类似于一个只读行数据 存储方式不同: 宏定义是直接替换，不会分配内存，存储与程序的代码段中； const常量需要进行内存分配，存储与程序的数据段中 是否可以做函数参数 宏定义不能作为参数传递给函数:const常量可以在函数的参数列表中出现 12、简单阐述下你认为运算符重载的意义\r#\r使程序更加简洁，增强程序的易读性。\n13、阐述下设计模式中单例模式的意义\r#\r单例模式 对于系统中的某些类来说，只有一个实例很重要，例如，一个游戏数据内容，整个游戏只有这么一份，在游戏进行到不同部分时，需要记录或访问该数据游戏数据。针对这种情况如果某个类只能有一个实例那么则满足我们的需求，我们将满足某个类只有一个实例的代码设计方式称为单例模式。\n单例模式的三要点：\n某个类只能有一个实例 必须自行创建这个实例 必须自行向外界提供这个实例 单例模式的实现步骤\n默认构造使用private修饰 内建该类的静态实例 静态构造方法中给该静态实例做初始化 对外提供获取该静态实例的方法 14、说一说你使用过得版本控制工具，描述下使用中的问题\r#\r项目的逻辑结构混乱\r#\r比如：开始时对需求不明确，导致软件本身结构混乱，使在定义软件的逻辑结构时，时常变化。又如：一个团队中，大家各自都之关心自己负责的模块，每个人各自制定适合自己的逻辑结构，导致最终的项目结构是一个大杂烩（多个结构组合而成）。久而久之，就会导致软件管理混乱，增加维护负担，反而降低效率。结构中，有的目录可能是“死角”，永远都没有使用到；有的目录可能是重复的，造成冗余；有的目录可能大家同时在用，各自对代码的修改彼此影响。\n多人修改同一个文件\r#\r在一般情况下，确保在任何时刻都只有一个成员对某个特定的文件进行修改，这样可以防止文件被其他成员的修改意外更新。为了适应多人同时修改同一个文件的情况，版本控制管理员也可以改变此缺省设置以允许对单个文件同时有多个签出（checkout），并且仍禁止对他人的修改进行覆盖。\n本地版本和服务器版本不一致\r#\r有时会碰到这样的情形，开发人员在从服务器那里更新本地版本时，只更新了部分内容，导致本地编译不通过。应该时刻注意保持本地版本和服务器版本的一致性，这是一个认识的问题，因为服务器版本才是真正唯一有效的。多个程序员还必须注意不要为了解决同一个问题而浪费时间。对某项功能的实现，由于本地和服务器的不一致，导致大家重复实现。\n用户权限混乱\r#\r对于所有开发人员和各自负责的模块，根据实际情况，制定合理的用户权限，哪些人对哪些目录只有可读权限，哪些人对哪些目录有读写权限。不应该出现所有人都是管理员这样的极端情况。\n手工修改文件的只读标记\r#\r为了防止你对没有签出的文件进行修改，版本控制管理工具会将这些文件指定并标明为只读文件。当你签出一个文件时，只读标记便被删去。一种经常出现的不良习惯是，为了图省事，在没有签出文件时便试图修改文件，当发现文件不能保存时，便手工修改其只读标记。这是一切混乱的“源头”，它将导致不一致、有效内容被覆盖等问题。\n没有指定工作目录或存在多个工作目录\r#\r每个开发人员必须拥有一个独一无二的工作目录，它不能与任何其他开发人员共享\n频繁的签入或很少签入\r#\r掌握好签入的时间，比如一天，或者在其他人需要的时候。并非每次微小的改动都需要马上签入，也并非每改完一个文件都将其签入，但也不要忘记签入。\n从服务器上获取最近版本时的疏忽\r#\r如果选择获取当前已经签出并且已经修改的文件最新版本，操作时必须非常小心。如果你选择取代文件，你将用最近一次签入的文件版本改写你做的修改，这可能会使你所做的工作白费。大多数情况下，最保险的做法是选定Apply To All Items，并选择Leave。\n15、cpp中，友元的优点和缺点\r#\r优点 提高了数据的共享性,加强了函数与函数之间,类与类之间的相互联系,提高程序的效率\n缺点 破坏了数据隐藏和数据封装,如果将类的封装比喻成一堵墙的话，那么友元机制就像墙上开了一个门。\n16、面相对象的特性\r#\r封装 封装是面向对象的特征之一，是对象和类概念的主要特性。封装就是把过程和数据包围起来，对数据的访问只能通过已定义的界面。如私有变量，用set，get方法获取。 封装保证了模块具有较好的独立性，使得程序维护修改较为容易。对应用程序的修改仅限于类的内部，因而可以将应用程序修改带来的影响减少到最低限度。 继承 一种联结类的层次模型，并且允许和鼓励类的重用，提供一种明确表达共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类(子类)，原始类称为新类的基类(父类)。派生类可以从它的父类哪里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。因此可以说，继承为了重用父类代码，同时为实现多态性作准备。 多态 多态是指允许不同类的对象对同一消息做出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活/抽象/行为共享/代码共享的优势，很好的解决了应用程序函数同名问题。总的来说，方法的重写，重载与动态链接构成多态性。 动态链接 \u0026ndash;\u0026gt;对于父类中定义的方法，如果子类中重写了该方法，那么父类类型的引用将调用子类中的这个方法，这就是动态链接。 17、面相对象的设计原则 六个\r#\r单一职责原则,一个合理的类，应该仅有一个引起它变化的原因，即单一职责,就是设计的这个类功能应该只有一个; 优点：消除耦合，减小因需求变化引起代码僵化\n开-闭原则，讲的是设计要对扩展有好的支持，而对修改要严格限制。即对扩展开放，对修改封闭。 优点：降低了程序各部分之间的耦合性，其适应性、灵活性、稳定性都比较好。当已有软件系统需要增加新的功能时，不需要对作为系统基础的抽象层进行修改，只需要在原有基础上附加新的模块就能实现所需要添加的功能。\n里氏代换原则，很严格的原则，规则是“子类必须能够替换基类，否则不应当设计为其子类。”也就是说，一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化。 优点：可以很容易的实现同一父类下各个子类的互换，而客户端可以毫不察觉。\n依赖倒换原则，“设计要依赖于抽象而不是具体化”。换句话说就是设计的时候我们要用抽象来思考，而不是一上来就开始划分我需要哪些哪些类，因为这些是具体。高层模块不应该依赖于底层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。要针对接口编程，不要针对实现编程。 优点：人的思维本身实际上就是很抽象的，我们分析问题的时候不是一下子就考虑到细节，而是很抽象的将整个问题都构思出来，所以面向抽象设计是符合人的思维的。另外这个原则会很好的支持（开闭原则）OCP，面向抽象的设计使我们能够不必太多依赖于实现，\n接口隔离原则，“将大的接口打散成多个小接口”，让系统解耦，从而容易重构，更改和重新部署。 优点：会使一个软件系统功能扩展时，修改的压力不会传到别的对象那里。\n迪米特法则或最少知识原则，这个原则首次在Demeter系统中得到正式运用，所以定义为迪米特法则。它讲的是“一个对象应当尽可能少的去了解其他对象”。 优点：消除耦合。\n17、阐述下智能指针的实现手段和意义\r#\r智能指针的一种通用实现技术是使用引用计数（reference count）。智能指针类将一个计数器与类指向的对象相关量，引用计数跟踪该类有多少个对象的指针指向同一个对象。\n原理 每次创建类的新对象时，初始化指针并将引用计数置位1；当对象作为另一对象的副本而创建时，拷贝构造函数拷贝拷贝并增加与之相应的引用计数： 对一个对象进行赋值，赋值操作符减少左操作数所指对象的引用计数（如果引用计数变为0，则删除对象），并增加右操作数所指对象的引用计数； 调用析构函数时，析构函数减少引用计数（如果引用计数减至0，则删除基础对象）。\n意义 保证使用堆上对象的时候，对象一定会被释放，但只能释放一次，并且释放后指向该对象的指针应该马上归 0。\n18、说出你认识的设计模式，阐述他们的特点，不少于五个\r#\r工厂模式\t用一个工厂方法或者类生成对象，来替换掉在在代码中直接new 对象的方式 单例模式\t构造方法私有化，通过静态的公有方法来获取实例对象 注册树模式\t将创建好的对象注册到全局树上面，是对象可以在任何地方被访问 适配器模式\t可以将截然不同的函数接口封装成统一的API 策略模式\t针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换 数据对象映射模式\t将对象和数据存储映射起来，对一个对象的操作会映射为对数据存储的操作 19、针对接口编程的意义\r#\r将具体逻辑与实现分开，减少了各个类之间的相互依赖，当各个类变化时，不需要对已经编写的系统进行改动，添加新的实现类就可以了，不在担心新改动的类对系统的其他模块造成影响。\n20、数组指针和指针数组区别\r#\r区别： 数组指针只是一个指针变量，它占有内存中一个指针的存储空间。 指针数组是多个指针变量，以数组形式存在内存当中，占有多个指针的存储空间。\n21、指针数组加减一是否有意义？为什么？\r#\r有，加减一是地址的偏移，偏移的值是数组中一个元素的空间大小\n22、阐述下二分查找法的时间复杂度是什么？\r#\r时间复杂度是说我们写的这段代码的运行时间 空间复杂度则是在说这段代码运行所占用的内存空间大小。 运用二分查找算法，在n个元素的数组中查找一个数，情况最遭时，需要(log2 n)步，所以二分查找的时间复杂度是O(log2 n)。 时间复杂度描述的就是非酋附体时的情况； 时间复杂度指的并非具体时间，而是操作数的增速。\n23、数据结构中栈和队列区别\r#\r队列与栈的定义：\r#\r队列（Queue）：是限定只能在表的一端进行插入和在另一端进行删除操作的线性表； 栈（Stack）：是限定只能在表的一端进行插入和删除操作的线性表。\n队列与栈的区别\r#\r队列和栈是两种不同的数据结构。它们有以下区别：\n操作的名称不同。 队列的插入称为入队，队列的删除称为出队。栈的插入称为进栈，栈的删除称为出栈。 操作的限定不同。 队列是在队尾入队，队头出队，即两边都可操作。而栈的进栈和出栈都是在栈顶进行的，无法对栈底直接进行操作。 操作的规则不同。 队列是先进先出（FIFO），即队列的修改是依先进先出的原则进行的。新来的成员总是加入队尾（不能从中间插入），每次离开的成员总是队列头上（不允许中途离队）。而栈为后进先出（LIFO）,即每次删除（出栈）的总是当前栈中最新的元素，即最后插入（进栈）的元素，而最先插入的被放在栈的底部，要到最后才能删除。 遍历数据速度不同。 队列是基于地址指针进行遍历，而且可以从头部或者尾部进行遍历，但不能同时遍历，无需开辟空间，因为在遍历的过程中不影响数据结构，所以遍历速度要快。栈是只能从顶部取数据，也就是说最先进入栈底的，需要遍历整个栈才能取出来，而且在遍历数据的同时需要为数据开辟临时空间，保持数据在遍历前的一致性。 24、cpp中头文件的意义\r#\r将函数和变量的声明跟定义分开\n当某一个.cpp源文件需要它们时，它们就可以通过一个宏命令 “#include”包含进这个.cpp文件中，从而把它们的内容合并到.cpp文件中去。\n25、内联函数的意义\r#\r提高函数的执行效率。用关键字 inline 放在函数定义的前面即可将函数指定为内联函数，内联函数通常就是将它在程序中的每个调用点上“内联地”展开，\n26、斐波那契数列\r#\r这个数列从第3项开始，每一项都等于前两项之和。\n27、动态规划\r#\r将一个问题拆成几个子问题，分别求解这些子问题，即可推断出大问题的解。\n如何判断一个问题能否使用DP解决呢？\n能将大问题拆成几个小问题，且满足无后效性、最优子结构性质。\n28、数组排序\r#\r冒泡排序法：将数组中的相邻两个元素进行比较，将比较大（较小）的数通过两两比较移动到数组末尾（开始），执行一遍内层循环，确定一个最大（最小）的数，外层循环从数组末尾（开始）遍历到开始（末尾）. 冒泡排序 选择排序法：将要排序的数组分成两部分，一部分是从大到小已经排好序的，一部分是无序的，从无序的部分取出最小的放到已经排序的最后面。 选择排序 插入排序法：将要排序的数组分成两部分，每次从后面的部分取出索引最小的元素插入到前一部分的适当位置 插入排序 快速排序法：快速排序法号称是目前最优秀的算法之一，实现思路是，将一个数组的排序问题看成是两个小数组的排序问题，而每个小的数组又可以继续看成更小的两个数组，一直递归下去，直到数组长度大小最大为2。 29、正态分布\r#\r如果把数值变量资料编制频数表后绘制频数分布图（又称直方图，它用矩形面积表示数值变量资料的频数分布，每条直条的宽表示组距，直条的面积表示频数（或频率）大小，直条与直条之间不留空隙。），\n若频数分布呈现中间为最多，左右两侧基本对称，越靠近中间频数越多，离中间越远，频数越少，形成一个中间频数多，两侧频数逐渐减少且基本对称的分布，那一般认为该数值变量服从或近似服从数学上的正态分布。\n30、排序算法\r#\r比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。\n非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。\n31、二叉树\r#\r二叉树是一种特殊的树，在二叉树中每个节点最多有两个子节点，一般称为左子节点和右子节点（或左孩子和右孩子），并且二叉树的子树有左右之分，其次序不能任意颠倒。\n32、红黑树\r#\rR-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。 红黑树的特性:\n每个节点或者是黑色，或者是红色。 根节点是黑色。 每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！] 如果一个节点是红色的，则它的子节点必须是黑色的。 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 注意：\n特性(3)中的叶子节点，是只为空(NIL或null)的节点。 特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是自平衡的二叉树。 33、平衡二叉树\r#\r每个节点的子树的高度差不超过1的二叉树\n34、散列\r#\r散列就是利用一段存储空间存储数据（大小为Tablesize)，然后根据关键词可以生成一个数字，这个数字是在范围在0和Tablesize之间。这个将关键字映射到数字的办法叫做散列函数。其实散列就是一个线性表，只不过它的下标可以不是直接给出的，而是通过一个运算从关键字得出的。\n35、CDO class default object\r#\rUCLASS宏为UObject提供了一个描述其基于虚幻的类型的UCLASS的引用。每个UCLASS都维护一个名为“类默认对象”的对象，简称CDO。 CDO本质上是一个默认的“模板”对象，由类构造函数生成，之后未修改。可以为给定的Object实例检索UCLASS和CDO，尽管它们通常应该被认为是只读的。可以使用GetClass()函数随时访问Object实例的UCLASS。\nCDO是在引擎初始化时创建的，当引擎为每个类生成UClass对象时。每个UClass的实例都是在引擎初始化期间创建的，并被分配为该UClass的CDO。并且包含在反射系统中，如在编辑器可以操作类蓝图。Obj.cpp可以看到引擎CDO初始化创建。\n36、虚继承\r#\r为了解决多继承时的命名冲突和冗余数据问题，使得在派生类中只保留一份间接基类的成员。在多重继承的问题上防止二义性的产生。\n"},{"id":4,"href":"/docs/interview/written/dl/","title":"某公司笔试（1）","section":"笔试题","content":" 笔试题操作题\r#\r注意\n下面试题为某虚拟仿真公司真实面试题，招聘岗位虚幻引擎开发工程师\n注意题目中内容不一定正确，需要重新整理\n收录时间：2022年8月10日\n"},{"id":5,"href":"/docs/interview/written/nc/","title":"某公司笔试（10）","section":"笔试题","content":" 请写出输出结果______(4 分) #include \u0026lt;stdio.h\u0026gt; union { int i; char x[2]; } void main() { a.x[0] = 10; a.x[1] = 1; printf(\u0026#34;%d\u0026#34;, a.i); } int Func(int，int); 不可与下列哪个函数构成重载 (______________)(4分) A.int Func(int, int, int); B.double Func(int, double); C.double Func(double, double); D.double Func(int, int); this 指针存在的目的是 () (4分) A.保证基类公有成员在子类中可以被访问 B.保证基类私有成员在子类中可以被访问 C.保证基类保护成员在子类中可以被访问 D.保证每个对象拥有自己的数据成员，但共享处理这些数据成员的代码 在哪种派生方式中，派生类可以访问基类中的 protected 成员 (_) (4 分) A.protected 和 private B.public 和private C.摞代ubli狡疤孩和 protected D.仅protected 以下两条输出语句分别输出什么? (8 分) float a = 1.0f; float b = 0.0f; A.cout \u0026laquo; boolalpha \u0026laquo; ( (int)a == (nt\u0026amp;)a ) \u0026laquo; endl;___________________________ B.cout \u0026laquo; boolalpha \u0026laquo; ( (int)b == (int\u0026amp;)b ) \u0026laquo; endl;___________________________ 输出下面程序的输出结果。 #include \u0026lt;iostream.h\u0026gt; template\u0026lt;class T\u0026gt; class Sample { T n; public: Sample(T i) { n = i; } int operator==(Sample\u0026amp;); } template\u0026lt;class T\u0026gt; int Sample\u0026lt;T\u0026gt;::operator==(Sample\u0026amp; s) { if(n==s.n) return l; else return 0; } void main() { Sample\u0026lt;double\u0026gt; s1(2.5)，s2(2.5); cout\u0026lt;\u0026lt;\u0026#34;s1与 s2 的数据成员\u0026#34;\u0026lt;\u0026lt;(sl==s2 ?\u0026#34;相等\u0026#34;:\u0026#34;不相等\u0026#34;)\u0026lt;\u0026lt;endl;________________________________ Sample\u0026lt;int\u0026gt; s3(2)，s4(3); cout\u0026lt;\u0026lt;\u0026#34;s3与s4 的数据成员\u0026#34;\u0026lt;\u0026lt;(s3==s4?\u0026#34;相等\u0026#34;:\u0026#34;不相等\u0026#34;)\u0026lt;\u0026lt;endl;_________________________________ } 以下三条输出语句分别输出什么?(9 分) char str1[] = \u0026#34;abc\u0026#34;; char str2[] = \u0026#34;abc\u0026#34;; const char str3[] = \u0026#34;abc\u0026#34;; const char str4[] = \u0026#34;abc\u0026#34;; const char* str5 = \u0026#34;abc\u0026#34;; const char* str6 = \u0026#34;abc\u0026#34;; A.cout \u0026laquo; boolalpha \u0026laquo;( strl==str2 ) \u0026laquo; endl;____________ B.cout \u0026laquo; boolalpha \u0026laquo;( str3==str4 ) \u0026laquo; endl;____________ C.cout \u0026laquo; boolalpha \u0026laquo;( str5==str6 )\u0026laquo; endl;____________ 检查ABCD 四个表达式的是否正确，著正确，写出经过表达式中 的值，老不正确，请写出原团(2 分) int a = 4; A.a += (a++);_________ B.a += (++a);_________ C.(a++)+=a;_________ D.(++a)+=(a++);_________ 关键宇explicit 有什么作用?(4分)\n请写出输出结果:\n#include\u0026lt;iostream\u0026gt; using namespace std; const char a =\u0026#39;\u0026#39;; const char b=\u0026#39;*\u0026#39;; int main(int argc, char* argv[]) { char str[31] = \u0026#34;Sorry, what\u0026#39;s your name again?\u0026#34;; char* p = str + sizeof(str) - 2; char*q = p + 1; while (str != p--) { if(a == *p) { for (int i= l;p + i != q; ++i) { cout \u0026lt;\u0026lt; *(p + i); } cout \u0026lt;\u0026lt; b; q = p; } if(str == p) { for (int i= 0; p + i != q; ++i) { cout \u0026lt;\u0026lt; *(p + i); } } } return 0; } 判断字符串是否为回纹（写出伪代码即可） bool isSymmerty(const char* p) { } 编程:如何判断一个单链表是否是环形链表?(7 分)(写出伪代码) struct node { char val; node* next; } bool check(const node* head) { } 设计程序：A文件中有一组整数，要求使用冒泡排序后输出到另一个文件中(20分) "},{"id":6,"href":"/docs/interview/written/gamegou/","title":"某公司笔试（2）","section":"笔试题","content":" 北京游戏公司笔试题\r#\r注意\n北京某游戏公司招聘面试笔试题\n收录时间：2022年8月10日\n100 个小朋友围成一个圈，设定编号为 1~100，依次按 1、2、3、4、5、6、7、8、9 循 环报数，报到 9 的出圈，直到所有小朋友出圈。请写代码打印出各个小朋友出圈顺序，语言 不限\n商场新进了两种商品 A 和 B，现在有 A 和 B 商品的购买记录，例如 A=[1,2,2,3,4,5], B=[2,4,1,2,3]。1,2,3,4,5 为用户编号。现在需要求出购买过 A、B 两种商品的用户，语言不限。 （结果中的每个用户编号必须是唯一的）\n例：\nInput:\n1,2,2,3,4,5\n2,4,1,2,3\noutput:\n1,2,3,4\n"},{"id":7,"href":"/docs/interview/written/zy/","title":"某公司笔试（3）","section":"笔试题","content":" 北京某公司笔试题\r#\r注意\n公司为北京游戏公司招聘虚幻引擎开发工程师\n注意题目中内容不一定正确，需要重新整理\n收录时间：2022年1月25日\n"},{"id":8,"href":"/docs/interview/written/gx/","title":"某公司笔试（4）","section":"笔试题","content":" 北京某公司笔试题\r#\r注意\n公司为某公司招聘C++开发工程师\n收录时间：2021年8月15日\n"},{"id":9,"href":"/docs/interview/written/zl/","title":"某公司笔试（5）","section":"笔试题","content":" 某游戏公司笔试题\r#\r注意\n游戏公司C++开发工程师\n答案仅供参考，需要自行校验对错\n收录时间：2021年8月15日\n"},{"id":10,"href":"/docs/interview/written/yh/","title":"某公司笔试（6）","section":"笔试题","content":" 某游戏公司笔试题\r#\r注意\n游戏公司C++开发工程师\n答案仅供参考，需要自行校验对错\n"},{"id":11,"href":"/docs/interview/written/hx/","title":"某公司笔试（7）","section":"笔试题","content":"\rUE4研发工程师笔试题(30min)\r#\r遍历删除一个 List 中的第偶数个元素.请写出伪代码 请简述字节流和字符流的区别和用途 单例类如何确保线程安全? 静态库和动态库有何区别? 请简述线程间进行数据传递的方法 请简述进程间进行数据传递的方法 请简述骨骼动画的概念 欧拉角的作用是什么?请简述欧拉角/四元数/旋转矩阵之间的关系和优劣 Unity默认是 y-up 坐标系，而UE4是z-up 的.给定UE4 中一个骨骼的欧拉角，如何转换到Unity 中? 您是否有在 UE4 中使用多线程的经验? 请简述功能和实现方式 UE4 的网络框架是如何同步的? 如何将 Camera 实时渲染图片并存本地文件? 请大略表述思路 和服务器通信时，你会依据哪些因素选取通信协议? 选用TCP/Http/Websocket 的场景分别是? "},{"id":12,"href":"/docs/interview/written/rt/","title":"某公司笔试（8）","section":"笔试题","content":"\r一、选择题（每题3分，10题，共30分）\r#\r某32位系统下，下面两个sizeof的结果分别是？（ A ） char str1[] = “http://www.nd.com.cn/”; sizeof（str1）; void Foo（char str2[100]） { sizeof（str2）; }; A. 4、4 B. 22、100 C. 22、4 D. 4、100 C++编译器区分重载函数的可能方式中，不能作为依据的是（D） A. 参数个数 B. 参数类型 C. 函数名 D. 函数返回值类型 设栈最大长度为3，入栈序列为1.2.3.4.5.6，则不可能得出栈序列是？（ D ） A．1.2.3.4.5.6 B．2.1.3.4.5.6 C．3.4.2.1.5.6 D．4.3.2.1.5.6 对于派生类的构造函数，在定义对象时构造函数的执行顺序为？1．成员对象的构造函数2．基类的构造函数3．派生类本身的构造函数（ D ） A．123 B．231 C．321 D．213 如何减少换页错误？（ B ） A. 进程倾向于占用CPU B. 访问局部性（locality of reference）满足进程要求 C. 进程倾向于占用I/O D. 使用基于最短剩余时间（shortest remaining time）的调度机制 foo.GetI（）的值是？（ C ） class Foo { public: Foo（int i） : m_i（i） {} Foo（） { Foo（1） } int GetI（void） { return m_i; } private: int m_i; }; Foo foo; A．0 B．-1 C．1 D．不可预知 下列程序的输出结果是？（ C ） int i = 8; switch（i） { case 9: i = i+1; default: i = i+1; case 10: i = i+1; case 11: i = i+1; } cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; A．9 B．10 C．11 D．12 float a=2，b=4，h=3;以下C语言表达式与代数式计算结果不相符的是？（ B ） A.（a+b）*h/2 B.（1/2）*（a+b）*h C.（a+b）h1/2 D. h/2*（a+b） 设有98个已排序列元素，采用二分法查找时，最大比较次数是？（ D ） A．49 B．8 C．20 D．7 下面哪种情况下，B不能隐式转换为A？（ B ） A.class B:public A{} B.class A:public B{} C.class B{operator A（）;} D.class A{A（const B\u0026amp;）;} 二、简答题（每题5分，12题，共60分）\r#\r#include\u0026lt;head.h\u0026gt;和#include”head.h”有什么区别？ 尖括号\u0026lt;head.h\u0026gt; 表明这是一个工程或者标准的头文件，在预处理过程中会首先检查系统预定义的目录，如果没有找到就报错。 引号”head.h” 表明这是一个用户自定义的头文件，查找文件的时候，会优先在当前文件目录中查找，如果没找到，会再去系统预定义的目录中查找，如果再没找到，则报错。\n指针和引用有什么区别？ 指针是一块内存地址，引用则是指针的别名。 指针可以为空，引用不能为空。 引用的创建和销毁，不会调用类的拷贝构造函数和析构函数\nC++类中，默认情况下会产生哪些类成员函数？ 默认构造函数 拷贝构造函数 默认赋值函数 析构函数\nC++中 const的用法？ 定义常量及数组 修饰指针和引用 函数中的参数和返回值 修饰对象\nStatic的用法？ 静态变量 静态函数 静态代码块 静态内部类\nStrcpy 和 memcpy有什么区别？ 复制的内容不同 复制的方法不同 用途不同\nVector和deque有什么区别？在应用时该如何选择？ 都是连续储存结构 Vector支持高效的随机访问，在尾端插入或删除的操作 Deque提供了俩级数组结构，支持头尾两端的插入删除操作 如果需要高效的随机存取，而不在乎插入和删除的效率，用Vector 如果需要随机存取，还需要两端数据的插入删除，用Deque\n虚函数和纯虚函数有什么区别？ 虚函数：抽象出一种方法，自己可以实现该方法，子类可以不重写。 纯虚函数：抽象出一种方法，自己不能实现该方法，强制子类重写\n有了malloc/free，为什么还要new/delete？ malloc/free是c/c++中的标准库函数，new/delete是c++中的运算符。它们都用于申请动态内存和释放内存。\n对于非内部数据对象(eg：类对象)，只用malloc/free无法满足动态对象的要求。这是因为对象在创建的同时需要自动执行构造函数，对象在消亡之前要自动执行析构函数，而由于malloc/free是库函数而不是运算符，不在编译器的控制权限内，也就不能自动执行构造函数和析构函数。因此，不能将执行构造函数和析构函数的任务强加给malloc/free。所以，在c++中需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理和释放内存工作的运算符delete。\nnew建立的是一个对象，malloc分配的是一块内存区域，用指针来访问，并且可以在区域里面移动指针；\n对于内部数据类型，由于其没有构造函数和析构函数的要求，对于内部数据类型来讲，malloc/free和new/delete的作用是等价的，都是用来申请动态内存和释放内存。\n怎样预防内存泄漏，有哪些检测方法？ 养成良好习惯，保证malloc/new和free/delete匹配。 检查malloc/new和free/delete是否匹配，一些工具也就是这个原理。 利用宏或者钩子，在用户程序与运行库之间加了一层，用于记录内存分配情况。\n请简述TCP/IP、HTTP、Socket这几个概念的区别和联系？\nTCP/IP协议：Transmission Control Protocol/Internet Protocol的简写，中译名为传输控制协议/因特网互联协议，又名网络通讯协议，是Internet最基本的协议、Internet国际互联网络的基础，是一组协议族。TCP/IP 定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。协议采用了4层的层级结构（应用层、传输层、网络层、网络接口层），每一层都呼叫它的下一层所提供的协议来完成自己的需求。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。\nHTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。\n网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。\nSocket是一个针对TCP和UDP编程的接口，你可以借助它建立TCP连接等等。而TCP和UDP协议属于传输层 。而http是个应用层的协议，它实际上也建立在TCP协议之上。\nSocket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们使用TCP/IP协议。Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已， 是对TCP/IP协议的抽象，从而形成了我们知道的一些最基本的函数接口。\n请列举出三个用于线程间同步的Windows内核对象，简述它们的基本概念及其适用环境？ 事件内核对象 在所有的内核对象中，事件内核对象是个最基本的对象。它们包含一个使用计数（与所有内核对象一样），一个用于指明该事件是个自动重置的事件还是一个人工重置的事件的布尔值，另一个用于指明该事件处于已通知状态还是未通知状态的布尔值。 事件能够通知一个操作已经完成。有两种不同类型的事件对象。一种是人工重置的事件，另一种是自动重置的事件。当人工重置的事件得到通知时，等待该事件的所有线程均变为可调度线程。\n等待定时器内核对象 等待定时器是在某个时间或按规定的间隔时间发出自己的信号通知的内核对象。它们通常用来在某个时间执行某个操作。若要创建等待定时器，只需要调用 C r e a t e Wa i t a b l e Ti m e r函数 3.信标内核对象 信标内核对象用于对资源进行计数。它们与所有内核对象一样，包含一个使用数量，但是它们也包含另外两个带符号的 3 2位值，一个是最大资源数量，一个是当前资源数量。 最大资源数量用于标识信标能够控制的资源的最大数量，而当前资源数量则用于标识当前可以使用的资源的数量。 三、编程题（1题，共10分）\r#\r写出int strlen（const char *str）方法，要求方法中不能有局部或者全局变量 Int strlen(const char *str) { If(‘\\0’ == *str) { return 0; } else{ return strlen(str+1) +1 } } "},{"id":13,"href":"/docs/interview/written/cpp/","title":"某公司笔试（9）","section":"笔试题","content":"\rC++基础\r#\r一、选择题\r#\r在C++中，数组类型属于（） A.本数据类型 B.自定义数琳类型 C.类类型 D.结构体类型 若有语句:float array[3][5][7];则数组array 的元素个数为() A.3 B.5 C.7 D.105 关于析构函数，下面说法不正确的是() A.析构函数用来完成对象被删除前的一些清理工作 B.析构函数可以声明为重载函数 C.析构函数可以声明为虚函数 D.析构函数在对象的生存期即将结束时被系统自动调用 关于抽象类，下列说法不正确的是() A.抽象类不能实例化 B.带有虚函数的类称为抽象类 C.带有纯虚函数的类称为抽象类 D.抽象类的作用是为一个类族建立一个公共接口 下列对一维数组a的正确定义是() A.int n=5,a[n]; B.int a(5); C.const int n-5;int a[n]; D.int n;cin\u0026raquo;n;int a[n]; 下列数组定义语句中，不合法的是() A.int a[3]={0,1,2,3}; B.int a[]={0,1,2}; C.int a[3]={0,1,2}; D.int a[3]={0}; 己知int a[10]={0，1，2，3，4，5，6，7，8，9}和*p=a，则不能表示数组a中元素的式子是()。 A.*a B.*p C.a D.a[p-a] 已知char *a[]={\u0026ldquo;fortraan\u0026rdquo;, \u0026ldquo;basic\u0026rdquo;, \u0026ldquo;pascal\u0026rdquo;, \u0026ldquo;java\u0026rdquo;, \u0026ldquo;c++\u0026quot;}，则cout\u0026laquo;a[3]，的显示结果是（） A.basie B.paseal C.java D.javact+ 若用数组名作为调用函数的实参，则传递给形参的是() A.数组存储首地址 B.数组第一个元素的值 C.数组元素的个数 D.数组中全部元素的值 判字符串sl和s2是否相等的正确表达式是（） A.s1=s2: B.s1==s2; C.strcmp(sl,s2)==0; D.strcpy(sl,s2); 下面选项中，不是类的成员函数的为() A.构造函数 B.析构函数 C.友元函数 D.拷贝构造雨数 不论派生类以何种方式继承基类，都不能使用基类的() A.public成员 B.private成员 C.protected成员 D.public和protected成员 在一个派生类中重新定义基类的虚函数时，应使() A.函数名相同，但参数不同; B.函数名相同，但函数返回值类型不同; C.函数名、函数返回值类型、参数个数、参数类型和顺序各不相同 D.函数名、函数返回值类型、参数个数、参数类型和顺序完全相同 如果把基类的析构函数声明为虚函数，则() A.各派生类的析构函数均自动为虚函数; B.派生类的析构函数与基类析构函数不同名，故不是虚函数; C:每个派生类的析构函数都必须声明为虚函数; D.只有基类的析构函数是虚函数。 派生类的对象可以访间()。 A.公有继承的基类的公有成员 B.公有继承的基类的保护成员 C.公有继承的基类的私有成员 D.保护继承的基类的公有成员 在创建派生类对象时，构造函数的执行顺序是() A.对象成员构造函数、基类构造函数、派生类本身的构造函数 B.派生类本身的构造函数、基类构造函数、对象成员构造函数 C.基类构造雨数、派生类本身的构造函数、对象成员构造函数 D.基类构造函数、对象成员构造函数、派生类本身的构造函数 17.下面函数原型声明中，声明fun为纯虚函数的是()\nA.void fun0=0: B.virtual void fun()=0; C.virtual void fun(); D.virtual void fun(){}; 一个类可以有多个构造函数，这些构造函数之间的关系是() A.重载 B.重复 C.拷贝 D.覆盖 下列对于int *pa[5]的描述，正确的是() A.pa是一个指向数组的指针，所指向的数组是5个int 型元素 B.pa是一个指向某数组中的第5个元素的指针，该元素是 int 型变量 C.pa[5]表示某个数组的第5个元素的值 D.pa是一个具有5个元素的指针数组，每个元素是一个int型指针 若有如下声明:class A{ int a;};则a是类A的() A.公有数据成员 B.公有成员函数 C.私有数据成员 D.私有成员函数 二、操作题(写出伪代码即可)\r#\r在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下的顺序排列。请完成一个函数，输入这样一个二维数组和一个整数。判断整数是否在这个数组内 举例\n1 2 8 9 2 4 9 12 4 7 10 13 6 8 11 15 输入7，返回true,输入5返回false\n给出一个字符类型的数组 word,请在单词间做边序。只需做到单词顺序逆序即可，对空格的位置没特别要求。 举例:如果word为\u0026quot;i like unreal engine”,调整后的结果为engineunreal like i\n给定一个整形数组arr，返问排序后的相邻两数的最人差值,如果arr的长度为N，请让你的算法做到时间复杂度为0(N)例:arr=[9,3,1,10].如果排序，结果为[1,3,9,4],9和3的差为最大差值，因此返回6 arr=[1,1,1,1]返回0\n在二维坐标系中，所有的值都是 double类型那么一个三角形可以由3个点来代表，给定任意三个点代表的三角形，在给定一个点(x,y),判断(x,y)是否在三角形中\n虚幻引擎基础\r#\r简答题\r#\r请简述GameMode, GameState, PlayerState. PlayerController, Pawn 的功能,和相互的关系： Gamelnstance 的功能有哪些，一共可以存在多少个? Selector、Sequence的节点功能? 在C++和蓝图中如何打印调试信息，c++请写出代码，蓝图请写出节点名称。 UObject和AActor有什么区别？ BlueprintlmplementableEvent 和BlueprintNativeEvent 的区别 如何在c++中实现Run On Server的函数声明并且在蓝图可调用? "},{"id":14,"href":"/docs/interview/qa/anyone/","title":"零散整理","section":"问答题","content":"\r内容来自面试回顾\r#\r本序列问题会不停更新\n以下内容为一些面试后的回顾总结，可能会有少许偏差！\r收集（一）\r#\rGameplayAbility 是什么? 通常用于处理什么? 如果需要应用一个持续时间内提高20%最大生命并不可叠加，要如何设置? GameplayEffect在执行时可以同时激活它所携带的能力么? Gameplay Effe ctExecutionCalculation它的功能是什么，它在什么情况下可能执行? GameplayEffect中的AssetTag 和 GeneratedTag 分别表示什么 如果需要某一个GameplayEffect免疫某一种状态，要如何处理 如果需要在执行GE前应用自定义属性，要如何处理 你认为GameplayAbility用于物品的应用，有哪些优点和缺点 如果设置某技能带有冷却和消耗的能力。 GameplayCue是什么，用它来处理什么。 如何发送GameplayEvent GameplayAttributeset是什么，可以在这里处理哪些逻辑。 当受到伤害时，20%几率对目标造成受到伤書的50%，要如何处理 收集（二）\r#\r面试北京某游戏公司后将问题进行整理总结\n简单聊一下GamePlay框架 比如新建一个地图，然后你再编辑器里运行起来，生成一个角色，编辑器做了一个什么事情，是怎么让这个程序跑起来的 你的角色换装是怎么做的 买的模型怎么保证他的骨骼是一致的呢 你做的这个模型大概有多少根骨骼呢 动画里播一个角度声音，衰减声音怎么做 动画播放到某一帧我想运行一个特效该怎么做 简单讲一讲UE的行为树结构 比如说有一个NPC有几种Idle动画，如何在行为树里边随机播一个（非U++） 简单讲一讲虚幻的RPC网络架构 讲一讲C++11里边Lambda表达式怎么用 讲一讲auto关键字吧，什么时候在auto后边加个*，什么时候在auto后边加个引用 讲一讲UE里边常用的数据结构有哪些 讲一讲TArray和C++STL里边的vector容器有什么区别 编程过程中有哪些崩溃让你记忆犹新，怎么解决的 讲一讲C++中常见的代码崩溃（数据操作） 收集（三）\r#\r同样面试游戏公司的面试题整理比较多\n用过虚幻4?你虚幻里面主要用C++还是蓝图进行开发？ C++和蓝图优势在哪里体现？ 多人团队开发协作用什么软件? 虚幻项目中能用SVN和GIT吗? 用过perforce吗？ Perforce做什么的？ 为什么用perforce？ 对C++有什么了解吗？C++和JAVA，VB这些有什么区别呢？ 和JAVA比有哪些优势? 怎么理解C++中的虚函数？ 虚函数在内存方面是重载还是覆盖？ 子类里拥有父类的内存空间吗？ 说说C++中结构体和类的区别是什么？ 虚幻当中的结构体和正常C++中的结构体有没有区别？ 在虚幻里面用C++里面的指针转换会有什么隐患？ 在一个类中有三个变量是int类型那么这个类所占的内存多大？ 全局变量会存在哪个地方？ 如果const一个全局变量会存在哪个地方？ 你能说一下栈在程序里面有什么作用？ C++11比原生C++多了些啥？ Lambda是什么? 仿函数是C++11的新特性吗 谈谈你对类的方法后面加不加Override有什么理解？ 谈谈final和override的区别？ 用没用过automic? 能说说线程和定时器的区别吗? Timer用过吗? Timer 的实现原理了解吗？ C和C++的区别? 说说你对虚幻的整个引擎架构的理解？ 你对FPS游戏作弊是怎么产生的有了解吗？ 通过什么来同步数据的呢？ 假如说想要实现客户端和服务器同步的操作你需要用虚幻的哪些API和接口呢? 解释解释DS服务器和GS服务器有啥区别? Lab服务器是在哪个上面运行的? 如何解决枪械穿模问题？ 游戏当中作弊玩家改高跳 你该怎么检查？ 普通的C++开发程序做过吗? 怎么检查内存泄露? 怎么实现函数进入上锁出去解锁? 怎么解决大地图卡顿? 聊聊ECS设计模式 收集（四）\r#\r以下问题比较模糊，建议只看不用整理\nC++多线程 C++多继承 虚幻如何多继承 RPC的各个关键字的职责和应用场景 变量的同步方式 虚幻的容器（数据结构） 容器如何使用容易造成崩溃 没有智能指针前如何处理内存泄漏 stl变成容器的内存分配具体是怎样的 main函数执行前和之后发生了什么事情 收集（五）\r#\r如何计算旋转\u0026lt;内部实现机制\u0026gt;？ 怎么计算四元数？ 怎么把自身坐标转换为世界坐标\u0026lt;内部实现机制\u0026gt;？ 虚幻的反射机制是什么？ 你知道标记宏UPerponty内部实现代码吗？ 构造函数有哪几种？ 左右值的区别？ 虚幻网络中为什么勾选了复制以后就可以进行网络？ 是什么决定引擎的性能？ 什么是数据结构？ 你的项目遇到的最大的问题？ UHT和UBT是什么？ "}]